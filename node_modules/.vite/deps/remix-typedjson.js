import {
  Await,
  useActionData,
  useFetcher,
  useLoaderData,
  useMatches
} from "./chunk-GAIXOCIK.js";
import {
  require_jsx_runtime
} from "./chunk-CTRIHH5C.js";
import "./chunk-ZRJG7NCB.js";
import "./chunk-2EXEP7CN.js";
import {
  defer,
  init_esm
} from "./chunk-X4NZADQQ.js";
import {
  __toESM
} from "./chunk-WXXH56N5.js";

// node_modules/remix-typedjson/dist/esm/remix.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
init_esm();

// node_modules/remix-typedjson/dist/esm/typedjson.js
var customTypeMap = /* @__PURE__ */ new Map();
function registerCustomType(entry) {
  customTypeMap.set(entry.type, entry);
}
function serialize(data) {
  if (data === null)
    return { json: "null" };
  if (data === void 0)
    return { json: void 0 };
  const stack = [];
  const keys = [""];
  const meta = /* @__PURE__ */ new Map();
  const customTypeMapValues = Array.from(customTypeMap.values());
  function replacer(key, value) {
    function unwindStack() {
      while (stack.length > 0) {
        const top = stack[stack.length - 1];
        if (top.iteration < top.count) {
          top.iteration++;
          return top;
        }
        if (top.type === "object") {
          keys.pop();
        }
        stack.pop();
      }
    }
    let entry = unwindStack();
    if (entry) {
      value = entry.value[key];
    }
    if (key.includes(".")) {
      key = `[${key}]`;
    }
    let metaKey = `${keys[keys.length - 1]}${key}`;
    const valueType = typeof value;
    if (valueType === "object" && value !== null) {
      let count = 0;
      let t = "undefined";
      if (value instanceof Date) {
        t = "date";
        value = value.toISOString();
      } else if (value instanceof Set) {
        value = Array.from(value);
        count = value.length;
        t = "set";
      } else if (value instanceof Map) {
        value = Object.fromEntries(value);
        count = Object.keys(value).length;
        t = "map";
      } else if (value instanceof Array) {
        t = "object";
        count = value.length;
      } else if (value instanceof RegExp) {
        t = "regexp";
        value = String(value);
      } else if (value instanceof Error) {
        t = "error";
        value = { name: value.name, message: value.message, stack: value.stack };
        stack.push({ type: "object", value, count: 3, iteration: 0 });
      } else {
        let customType;
        if (customTypeMapValues.length > 0) {
          customType = customTypeMapValues.find((entry2) => entry2.is(value));
        }
        if (customType) {
          t = customType.type;
          value = customType.serialize(value);
        } else {
          count = Object.keys(value).length;
          t = "object";
        }
      }
      if (t !== "object") {
        meta.set(metaKey, t);
      }
      if (count !== 0) {
        stack.push({ type: t, value, count, iteration: 0 });
        if (key && t === "object") {
          keys.push(`${metaKey}.`);
        }
        return value;
      }
    }
    if (valueType === "bigint") {
      meta.set(metaKey, "bigint");
      return String(value);
    }
    if (valueType === "number") {
      if (value === Number.POSITIVE_INFINITY) {
        meta.set(metaKey, "infinity");
        return "Infinity";
      }
      if (value === Number.NEGATIVE_INFINITY) {
        meta.set(metaKey, "-infinity");
        return "-Infinity";
      }
      if (Number.isNaN(value)) {
        meta.set(metaKey, "nan");
        return "NaN";
      }
    }
    if (typeof value === "undefined") {
      meta.set(metaKey, "undefined");
      return null;
    }
    return value;
  }
  const json = JSON.stringify(data, replacer);
  return {
    json,
    meta: meta.size === 0 ? void 0 : Object.fromEntries(meta.entries())
  };
}
function deserialize({ json, meta }) {
  if (typeof json === "undefined") {
    return void 0;
  }
  if (!json)
    return null;
  const result = JSON.parse(json);
  if (meta) {
    applyMeta(result, meta);
  }
  return result;
}
var splitKey = (key) => {
  const keys = [];
  const parts = key.split(".");
  for (let i = 0; i < parts.length; i++) {
    if (parts[i].startsWith("[")) {
      let k = parts[i].substring(1);
      let j = i + 1;
      while (!parts[j].endsWith("]")) {
        k += `.${parts[j]}`;
        j++;
      }
      k += `.${parts[j].slice(0, -1)}`;
      keys.push(k);
      i = j;
    } else {
      keys.push(parts[i]);
    }
  }
  return keys;
};
function applyMeta(data, meta) {
  const customTypeMapValues = Array.from(customTypeMap.values());
  for (const key of Object.keys(meta)) {
    const keys = splitKey(key);
    applyConversion(data, keys, meta[key]);
  }
  return data;
  function applyConversion(data2, keys, type, depth = 0) {
    const key = keys[depth];
    if (depth < keys.length - 1) {
      applyConversion(data2[key], keys, type, depth + 1);
      return;
    }
    const value = data2[key];
    switch (type) {
      case "date":
        data2[key] = new Date(value);
        break;
      case "set":
        data2[key] = new Set(value);
        break;
      case "map":
        data2[key] = new Map(Object.entries(value));
        break;
      case "regexp":
        const match = /^\/(.*)\/([dgimsuy]*)$/.exec(value);
        if (match) {
          data2[key] = new RegExp(match[1], match[2]);
        } else {
          throw new Error(`Invalid regexp: ${value}`);
        }
        break;
      case "bigint":
        data2[key] = BigInt(value);
        break;
      case "undefined":
        data2[key] = void 0;
        break;
      case "infinity":
        data2[key] = Number.POSITIVE_INFINITY;
        break;
      case "-infinity":
        data2[key] = Number.NEGATIVE_INFINITY;
        break;
      case "nan":
        data2[key] = NaN;
        break;
      case "error":
        const err = new Error(value.message);
        err.name = value.name;
        err.stack = value.stack;
        data2[key] = err;
        break;
      default:
        let customType = customTypeMap.get(type);
        if (customType) {
          data2[key] = customType.deserialize(value);
        }
    }
  }
}
function stringify(data, replacer, space) {
  if (replacer || space) {
    const { json, meta } = serialize(data);
    const jsonObj = deserialize({ json });
    return JSON.stringify({
      json: jsonObj,
      meta
    }, replacer, space);
  }
  return JSON.stringify(serialize(data));
}
function parse(json) {
  const result = JSON.parse(json);
  return result ? deserialize(result) : null;
}

// node_modules/remix-typedjson/dist/esm/remix.js
var typedjson = (data, init = {}) => {
  let responseInit = typeof init === "number" ? { status: init } : init;
  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(stringifyRemix(data), {
    ...responseInit,
    headers
  });
};
var typeddefer = (data, init = {}) => {
  Object.entries(data).forEach(([key, value]) => {
    if (value instanceof Promise) {
      ;
      data[key] = value.then((resolvedData) => {
        const { meta } = serialize(resolvedData);
        if (meta) {
          ;
          resolvedData["$$meta"] = meta;
        }
        return resolvedData;
      });
    } else {
      const { meta } = serialize(data);
      if (meta) {
        ;
        data["$$meta"] = meta;
      }
    }
  });
  let responseInit = typeof init === "number" ? { status: init } : init;
  return defer(data, responseInit);
};
function TypedAwait(props) {
  if (!props.children)
    return null;
  return (0, import_jsx_runtime.jsx)(Await, { ...props, children: (data) => {
    if (data === null)
      return null;
    let deserializedData = deserializeRemix(data);
    return props.children(deserializedData);
  } });
}
function useTypedLoaderData() {
  const data = useLoaderData();
  return deserializeRemix(data);
}
function useTypedActionData() {
  const data = useActionData();
  return deserializeRemix(data);
}
function useTypedFetcher(opts) {
  const fetcher = useFetcher(opts);
  if (fetcher.data) {
    const newData = deserializeRemix(fetcher.data);
    fetcher.data = newData ?? void 0;
  }
  return fetcher;
}
function useTypedRouteLoaderData(id) {
  const match = useMatches().find((match2) => match2.id === id);
  if (!match)
    return void 0;
  return deserializeRemix(match.data);
}
function stringifyRemix(data) {
  let { json, meta } = serialize(data);
  if (json && meta) {
    if (json.startsWith("{")) {
      json = `${json.substring(0, json.length - 1)},"$$meta":${JSON.stringify(meta)}}`;
    } else if (json.startsWith("[")) {
      json = `{"$$obj":${json},"$$meta":${JSON.stringify(meta)}}`;
    }
  }
  return json;
}
function deserializeRemix(data) {
  if (!data)
    return data;
  if (data.$$obj) {
    return data.$$meta ? applyMeta(data.$$obj, data.$$meta) : data.$$obj;
  } else if (data.$$meta) {
    const meta = data.$$meta;
    delete data.$$meta;
    return applyMeta(data, meta);
  }
  return data;
}
var redirect = (url, init = 302) => {
  let responseInit = init;
  if (typeof responseInit === "number") {
    responseInit = { status: responseInit };
  } else if (typeof responseInit.status === "undefined") {
    responseInit.status = 302;
  }
  let headers = new Headers(responseInit.headers);
  headers.set("Location", url);
  return new Response(null, {
    ...responseInit,
    headers
  });
};
export {
  TypedAwait,
  applyMeta,
  deserialize,
  deserializeRemix,
  parse,
  redirect,
  registerCustomType,
  serialize,
  stringify,
  stringifyRemix,
  typeddefer,
  typedjson,
  useTypedActionData,
  useTypedFetcher,
  useTypedLoaderData,
  useTypedRouteLoaderData
};
//# sourceMappingURL=remix-typedjson.js.map
