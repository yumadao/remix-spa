{
  "version": 3,
  "sources": ["../../remix-typedjson/dist/esm/remix.js", "../../remix-typedjson/dist/esm/typedjson.js"],
  "sourcesContent": ["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { Await, useActionData, useFetcher, useLoaderData, useMatches, } from '@remix-run/react';\nimport { defer } from '@remix-run/server-runtime';\nimport * as _typedjson from './typedjson';\nexport const typedjson = (data, init = {}) => {\n    let responseInit = typeof init === 'number' ? { status: init } : init;\n    let headers = new Headers(responseInit.headers);\n    if (!headers.has('Content-Type')) {\n        headers.set('Content-Type', 'application/json; charset=utf-8');\n    }\n    return new Response(stringifyRemix(data), {\n        ...responseInit,\n        headers,\n    });\n};\nexport const typeddefer = (data, init = {}) => {\n    // wrap any Promises in the data with new Promises that will serialize the\n    // resolved data and add the meta to the response\n    Object.entries(data).forEach(([key, value]) => {\n        if (value instanceof Promise) {\n            ;\n            data[key] = value.then(resolvedData => {\n                const { meta } = _typedjson.serialize(resolvedData);\n                if (meta) {\n                    ;\n                    resolvedData['$$meta'] = meta;\n                }\n                return resolvedData;\n            });\n        }\n        else {\n            const { meta } = _typedjson.serialize(data);\n            if (meta) {\n                ;\n                data['$$meta'] = meta;\n            }\n        }\n    });\n    let responseInit = typeof init === 'number' ? { status: init } : init;\n    return defer(data, responseInit);\n};\nexport function TypedAwait(props) {\n    if (!props.children)\n        return null;\n    return (_jsx(Await, { ...props, children: data => {\n            if (data === null)\n                return null;\n            let deserializedData = deserializeRemix(data);\n            return props.children(deserializedData);\n        } }));\n}\nexport function useTypedLoaderData() {\n    const data = useLoaderData();\n    return deserializeRemix(data);\n}\nexport function useTypedActionData() {\n    const data = useActionData();\n    return deserializeRemix(data);\n}\nexport function useTypedFetcher(opts) {\n    const fetcher = useFetcher(opts);\n    if (fetcher.data) {\n        const newData = deserializeRemix(fetcher.data);\n        fetcher.data = newData ?? undefined;\n    }\n    return fetcher;\n}\nexport function useTypedRouteLoaderData(id) {\n    const match = useMatches().find(match => match.id === id);\n    if (!match)\n        return undefined;\n    return deserializeRemix(match.data);\n}\nexport function stringifyRemix(data) {\n    // prevent double JSON stringification\n    let { json, meta } = _typedjson.serialize(data);\n    if (json && meta) {\n        if (json.startsWith('{')) {\n            json = `${json.substring(0, json.length - 1)},\\\"$$meta\\\":${JSON.stringify(meta)}}`;\n        }\n        else if (json.startsWith('[')) {\n            json = `{\"$$obj\":${json},\"$$meta\":${JSON.stringify(meta)}}`;\n        }\n    }\n    return json;\n}\nexport function deserializeRemix(data) {\n    if (!data)\n        return data;\n    if (data.$$obj) {\n        // handle arrays wrapped in an object\n        return data.$$meta\n            ? _typedjson.applyMeta(data.$$obj, data.$$meta)\n            : data.$$obj;\n    }\n    else if (data.$$meta) {\n        // handle object with $$meta key\n        // remove before applying meta\n        const meta = data.$$meta;\n        delete data.$$meta;\n        return _typedjson.applyMeta(data, meta);\n    }\n    return data;\n}\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n *\n * @see https://remix.run/api/remix#redirect\n */\nexport const redirect = (url, init = 302) => {\n    let responseInit = init;\n    if (typeof responseInit === 'number') {\n        responseInit = { status: responseInit };\n    }\n    else if (typeof responseInit.status === 'undefined') {\n        responseInit.status = 302;\n    }\n    let headers = new Headers(responseInit.headers);\n    headers.set('Location', url);\n    return new Response(null, {\n        ...responseInit,\n        headers,\n    });\n};\n", "let customTypeMap = new Map();\nexport function registerCustomType(entry) {\n    customTypeMap.set(entry.type, entry);\n}\nfunction serialize(data) {\n    if (data === null)\n        return { json: 'null' };\n    if (data === undefined)\n        return { json: undefined };\n    const stack = [];\n    const keys = [''];\n    const meta = new Map();\n    const customTypeMapValues = Array.from(customTypeMap.values());\n    function replacer(key, value) {\n        function unwindStack() {\n            while (stack.length > 0) {\n                const top = stack[stack.length - 1];\n                if (top.iteration < top.count) {\n                    top.iteration++;\n                    return top;\n                }\n                if (top.type === 'object') {\n                    keys.pop();\n                }\n                stack.pop();\n            }\n        }\n        let entry = unwindStack();\n        if (entry) {\n            value = entry.value[key];\n        }\n        // handle dotted keys\n        if (key.includes('.')) {\n            key = `[${key}]`;\n        }\n        let metaKey = `${keys[keys.length - 1]}${key}`;\n        const valueType = typeof value;\n        if (valueType === 'object' && value !== null) {\n            let count = 0;\n            let t = 'undefined';\n            if (value instanceof Date) {\n                t = 'date';\n                value = value.toISOString();\n            }\n            else if (value instanceof Set) {\n                value = Array.from(value);\n                count = value.length;\n                t = 'set';\n            }\n            else if (value instanceof Map) {\n                value = Object.fromEntries(value);\n                count = Object.keys(value).length;\n                t = 'map';\n            }\n            else if (value instanceof Array) {\n                t = 'object';\n                count = value.length;\n            }\n            else if (value instanceof RegExp) {\n                t = 'regexp';\n                value = String(value);\n            }\n            else if (value instanceof Error) {\n                t = 'error';\n                value = { name: value.name, message: value.message, stack: value.stack };\n                // push error value to stack\n                stack.push({ type: 'object', value, count: 3, iteration: 0 });\n            }\n            else {\n                // check for custom types\n                let customType;\n                if (customTypeMapValues.length > 0) {\n                    customType = customTypeMapValues.find(entry => entry.is(value));\n                }\n                if (customType) {\n                    t = customType.type;\n                    value = customType.serialize(value);\n                }\n                else {\n                    count = Object.keys(value).length;\n                    t = 'object';\n                }\n            }\n            if (t !== 'object') {\n                meta.set(metaKey, t);\n            }\n            if (count !== 0) {\n                stack.push({ type: t, value, count, iteration: 0 });\n                if (key && t === 'object') {\n                    keys.push(`${metaKey}.`);\n                }\n                return value;\n            }\n        }\n        // handle non-object types\n        if (valueType === 'bigint') {\n            meta.set(metaKey, 'bigint');\n            return String(value);\n        }\n        if (valueType === 'number') {\n            if (value === Number.POSITIVE_INFINITY) {\n                meta.set(metaKey, 'infinity');\n                return 'Infinity';\n            }\n            if (value === Number.NEGATIVE_INFINITY) {\n                meta.set(metaKey, '-infinity');\n                return '-Infinity';\n            }\n            if (Number.isNaN(value)) {\n                meta.set(metaKey, 'nan');\n                return 'NaN';\n            }\n        }\n        if (typeof value === 'undefined') {\n            meta.set(metaKey, 'undefined');\n            return null;\n        }\n        return value;\n    }\n    const json = JSON.stringify(data, replacer);\n    return {\n        json,\n        meta: meta.size === 0 ? undefined : Object.fromEntries(meta.entries()),\n    };\n}\nfunction deserialize({ json, meta }) {\n    if (typeof json === 'undefined') {\n        return undefined;\n    }\n    if (!json)\n        return null;\n    const result = JSON.parse(json);\n    if (meta) {\n        applyMeta(result, meta);\n    }\n    return result;\n}\nexport const splitKey = (key) => {\n    // key is a dotted path\n    // may contain escaped dots which are keys wrapped in []\n    // example [b.c].d => ['b.c', 'd']\n    const keys = [];\n    const parts = key.split('.');\n    for (let i = 0; i < parts.length; i++) {\n        if (parts[i].startsWith('[')) {\n            let k = parts[i].substring(1);\n            let j = i + 1;\n            while (!parts[j].endsWith(']')) {\n                k += `.${parts[j]}`;\n                j++;\n            }\n            k += `.${parts[j].slice(0, -1)}`;\n            keys.push(k);\n            i = j;\n        }\n        else {\n            keys.push(parts[i]);\n        }\n    }\n    return keys;\n};\nfunction applyMeta(data, meta) {\n    const customTypeMapValues = Array.from(customTypeMap.values());\n    for (const key of Object.keys(meta)) {\n        const keys = splitKey(key);\n        applyConversion(data, keys, meta[key]);\n    }\n    return data;\n    function applyConversion(data, keys, type, depth = 0) {\n        const key = keys[depth];\n        if (depth < keys.length - 1) {\n            applyConversion(data[key], keys, type, depth + 1);\n            return;\n        }\n        const value = data[key];\n        switch (type) {\n            case 'date':\n                data[key] = new Date(value);\n                break;\n            case 'set':\n                data[key] = new Set(value);\n                break;\n            case 'map':\n                data[key] = new Map(Object.entries(value));\n                break;\n            case 'regexp':\n                const match = /^\\/(.*)\\/([dgimsuy]*)$/.exec(value);\n                if (match) {\n                    data[key] = new RegExp(match[1], match[2]);\n                }\n                else {\n                    throw new Error(`Invalid regexp: ${value}`);\n                }\n                break;\n            case 'bigint':\n                data[key] = BigInt(value);\n                break;\n            case 'undefined':\n                data[key] = undefined;\n                break;\n            case 'infinity':\n                data[key] = Number.POSITIVE_INFINITY;\n                break;\n            case '-infinity':\n                data[key] = Number.NEGATIVE_INFINITY;\n                break;\n            case 'nan':\n                data[key] = NaN;\n                break;\n            case 'error':\n                const err = new Error(value.message);\n                err.name = value.name;\n                err.stack = value.stack;\n                data[key] = err;\n                break;\n            default:\n                // custom types\n                let customType = customTypeMap.get(type);\n                if (customType) {\n                    data[key] = customType.deserialize(value);\n                }\n        }\n    }\n}\nfunction stringify(data, replacer, space) {\n    if (replacer || space) {\n        const { json, meta } = serialize(data);\n        const jsonObj = deserialize({ json });\n        return JSON.stringify({\n            json: jsonObj,\n            meta,\n        }, replacer, space);\n    }\n    return JSON.stringify(serialize(data));\n}\nfunction parse(json) {\n    const result = JSON.parse(json);\n    return result ? deserialize(result) : null;\n}\nconst typedjson = {\n    serialize,\n    stringify,\n    deserialize,\n    parse,\n    applyMeta,\n};\nexport { applyMeta, deserialize, parse, serialize, stringify };\nexport default typedjson;\n"],
  "mappings": "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",
  "names": ["entry", "data", "_jsx", "match"]
}
